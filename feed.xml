<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://satpreetmakhija.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://satpreetmakhija.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-05T09:00:33+00:00</updated><id>https://satpreetmakhija.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Choosing the right axioms</title><link href="https://satpreetmakhija.github.io/blog/2025/choosing-the-right-axioms/" rel="alternate" type="text/html" title="Choosing the right axioms"/><published>2025-01-05T00:00:00+00:00</published><updated>2025-01-05T00:00:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2025/choosing-the-right-axioms</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2025/choosing-the-right-axioms/"><![CDATA[<p>I recently went down the rabbit hole of studying Real Analysis. As part of the first exercise, we constructed natural numbers using <strong>Peano’s axioms</strong>. One of these axioms is often described as “ensuring no circularity”—meaning we don’t define a natural number in terms of itself or create logical loops. Essentially, it’s the idea that \(0\) (or the “first” natural number) is not the successor of any other number. This ensures you can’t keep going backwards indefinitely and end up with something like “this number created itself.”</p> <p>This made me wonder: <strong>How do we choose the correct axioms in the first place?</strong></p> <p>I had a vague sense of what an axiom stands for: it’s something so fundamental that we just accept it, because denying it seems impossible if we want to build a coherent theory. For example, we accept the “no circularity” rule in Peano arithmetic because we know, from our usual understanding of how counting works, that numbers don’t loop back on themselves.</p> <p>In some sense, defining axioms is a backward process rather than a forward one: we look at the structures we already use—like arithmetic—and peel back the layers to find the simplest building blocks. For instance:</p> <ul> <li><strong>Multiplication</strong> can be defined as repeated addition.</li> <li><strong>Addition</strong> can be defined as repeated increment.</li> <li><strong>Increment</strong> (the “successor” operation) is often written as \(n \mapsto n + 1\) and is the point where we say, “Okay, we can’t break this down further.”</li> </ul> <p>So we stop at increment and make it an axiom: “There exists a successor function that behaves in this fundamentally simple way.” We basically say, “We can’t derive it from anything more basic, so we accept it as foundational.”</p> <p>Now, look at <strong>Euclidean geometry</strong>. It’s famously built from five postulates (axioms):</p> <ol> <li>A straight line segment can be drawn between any two points.</li> <li>Any finite straight line segment can be extended indefinitely in a straight line.</li> <li>A circle can be drawn with any center and any distance (radius).</li> <li>All right angles are equal to one another.</li> <li><em>(The Parallel Postulate)</em> If a straight line intersects two other straight lines such that the sum of the interior angles on one side is less than two right angles, those two lines (if extended far enough) will meet on that side.</li> </ol> <p>The first four seem pretty straightforward—basically describing how lines, segments, and circles behave. But the fifth one, the <strong>Parallel Postulate</strong>, says that if lines have certain angle properties, they’ll meet (or never meet) under certain conditions. Historically, Euclid tried to derive this from the first four but couldn’t. After centuries of attempts, mathematicians concluded the parallel postulate must stand on its own—so it’s part of the foundation.</p> <p>I recently read (in the footnotes of a book whose name I’ve unfortunately forgotten) a neat idea from <strong>Bertrand Russell</strong>. He suggested that one way we judge the strength or validity of our axioms is whether they lead us to statements we <em>already believe</em> to be true. So, for the natural numbers, we already have the idea that we can keep incrementing a number forever and it’ll keep getting bigger. That’s why we accept an axiom like \(n + 1 &gt; n\) —it neatly matches our intuition that numbers don’t loop back on themselves and can grow indefinitely.</p> <p>Here are a few general guidelines we can gather from this:</p> <ol> <li><strong>Work backwards</strong> to find the axioms that cannot be further derived.</li> <li><strong>Accept as axioms</strong> those that seem both intuitively reasonable and resistant to being proved by other axioms.</li> <li><strong>Use earlier results</strong> (like known theorems or observed truths) to test whether your axioms are powerful or consistent enough.</li> </ol> <p>The short version to choosing the right axioms is: we figure out the irreducible pieces, test them against what we think is “obviously true,” and then put them at the foundation of our system. That’s all “axioms” really are—rock-bottom assumptions that shape the entire universe that follows.</p> <p>To be honest, writing this post does make me wonder if I can do the same for choosing the right axioms to lead my life. I’ll tackle this in another post.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[A framework to help you choose the right axioms]]></summary></entry><entry><title type="html">How to avoid prompt injection attack by following prompt engineering best practices?</title><link href="https://satpreetmakhija.github.io/blog/2023/prompt-injection-attack/" rel="alternate" type="text/html" title="How to avoid prompt injection attack by following prompt engineering best practices?"/><published>2023-07-11T17:39:00+00:00</published><updated>2023-07-11T17:39:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2023/prompt-injection-attack</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2023/prompt-injection-attack/"><![CDATA[<p>Redirecting to another page.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[using language models in production comes with its own risks. Read the article to learn how to mitigate them.]]></summary></entry><entry><title type="html">GPUs: Why you can never have enough?</title><link href="https://satpreetmakhija.github.io/blog/2023/GPUs-substack-article/" rel="alternate" type="text/html" title="GPUs: Why you can never have enough?"/><published>2023-04-28T17:39:00+00:00</published><updated>2023-04-28T17:39:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2023/GPUs-substack-article</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2023/GPUs-substack-article/"><![CDATA[<p>Redirecting to another page.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[the real reason why GPUs are in demand and why it's not going to stop]]></summary></entry><entry><title type="html">Context Revolution: Taking machines beyond algorithm</title><link href="https://satpreetmakhija.github.io/blog/2023/Context-Revolution/" rel="alternate" type="text/html" title="Context Revolution: Taking machines beyond algorithm"/><published>2023-02-07T17:39:00+00:00</published><updated>2023-02-07T17:39:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2023/Context-Revolution</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2023/Context-Revolution/"><![CDATA[<p>The computation revolution started when we built general purpose computers to follow instructions. A computer follows an algorithm step by step. It doesn’t need to <i>understand</i> the algorithm.</p> <p>Here’s an example to illustrate the difference between <i>understanding</i> something and following an algorithm. There’s a world renowned chef, Andre, who makes a special pasta dish. Andre lost both his arms (sorry Andre). He hires you to make this dish. You don’t know anything about how to make this dish. You don’t know these ingredients, how they taste, which ones blend together. But, Andre is great at communication. He gives you step by step procedure to make the dish and you follow along with him. Voila! You made the special pasta only Andre knows how to make. Andre <i>understands</i> how to make this special pasta. You followed an algorithm. But what is it that Andre has that you don’t? Context. He knows the flavour of the ingredients, he knows what they taste like, he knows which ingredients complement each other and which don’t. He has context around the algorithm. This context is what I proxy for as understanding.</p> <p>The AI revolution is about giving computers more context around the computation they perform.</p> <p>“Write me a function to add five numbers.” - you give the prompt to a language model that runs on a computer. The computer doesn’t have an algorithm to give you the output you want. It only knows how to execute an algorithm. The language model contains the context to make head and tails of the prompt. We will provide this context to computers via AI such as natural language, our physical reality, our visual imagery, anything and everything we have access to. With time they will have as much context as we do. This is what I call the Context Revolution.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[how AI changes computations performed by a computer]]></summary></entry></feed>